/**
 * Êï∞ÊçÆÊ®°ÂûãÂÆö‰πâ
 * ÂèØÊâ©Â±ïÁöÑ‰∫ã‰ª∂Á≥ªÁªüÔºåÊîØÊåÅËá™ÂÆö‰πâ‰∫ã‰ª∂Á±ªÂûã
 */

// Êïå‰∫∫Á±ªÂûãÂÆö‰πâÊ≥®ÂÜåË°®
class EnemyTypeRegistry {
    constructor() {
        this.enemies = new Map();
        this.registerDefaultEnemies();
    }

    // Ê≥®ÂÜåÈªòËÆ§Êïå‰∫∫Á±ªÂûãÔºàÁé∞Âú®‰∏∫Á©∫ÔºåÁî®Êà∑Ëá™Ë°åÊ∑ªÂä†Ôºâ
    registerDefaultEnemies() {
        // ‰∏çÂÜçÊ≥®ÂÜåÈ¢ÑËÆæÊïå‰∫∫ÔºåÁî®Êà∑ÂèØ‰ª•Ëá™Ë°åÊ∑ªÂä†
        // Â∞ùËØï‰ªélocalStorageÂä†ËΩΩÂ∑≤‰øùÂ≠òÁöÑÊïå‰∫∫Êï∞ÊçÆ
        this.loadFromStorage();
    }

    // ‰ªélocalStorageÂä†ËΩΩÊïå‰∫∫Êï∞ÊçÆ
    loadFromStorage() {
        try {
            const saved = localStorage.getItem('wave_creator_enemies');
            if (saved) {
                const enemies = JSON.parse(saved);
                enemies.forEach(enemy => {
                    // Áõ¥Êé•ËÆæÁΩÆÔºå‰∏çËß¶Âèë‰øùÂ≠ò
                    this.enemies.set(enemy.id, enemy);
                });
            }
        } catch (error) {
            console.error('Âä†ËΩΩÊïå‰∫∫Êï∞ÊçÆÂ§±Ë¥•:', error);
        }
    }

    // ‰øùÂ≠òÂà∞localStorage
    saveToStorage() {
        try {
            const enemies = this.getAll();
            localStorage.setItem('wave_creator_enemies', JSON.stringify(enemies));
        } catch (error) {
            console.error('‰øùÂ≠òÊïå‰∫∫Êï∞ÊçÆÂ§±Ë¥•:', error);
        }
    }

    // Ê≥®ÂÜåÊñ∞ÁöÑÊïå‰∫∫Á±ªÂûã
    register(id, config) {
        this.enemies.set(id, {
            id,
            name: config.name || id,
            icon: config.icon || 'üëæ',
            scenePath: config.scenePath || '',
            uid: config.uid || '',
        });
        // ÊØèÊ¨°Ê≥®ÂÜåÂêéËá™Âä®‰øùÂ≠ò
        this.saveToStorage();
    }

    // Ëé∑ÂèñÊïå‰∫∫Á±ªÂûã
    get(id) {
        // Â¶ÇÊûúÊåáÂÆöIDÂ≠òÂú®ÔºåËøîÂõûÂÆÉ
        if (this.enemies.has(id)) {
            return this.enemies.get(id);
        }
        // Âê¶ÂàôËøîÂõûÁ¨¨‰∏Ä‰∏™ÂèØÁî®ÁöÑÊïå‰∫∫ÔºåÂ¶ÇÊûúÊ≤°ÊúâÊïå‰∫∫ÂàôËøîÂõûnull
        const firstEnemy = this.enemies.values().next().value;
        return firstEnemy || null;
    }

    // Ëé∑ÂèñÊâÄÊúâÊïå‰∫∫Á±ªÂûã
    getAll() {
        return Array.from(this.enemies.values());
    }

    // Âà†Èô§Êïå‰∫∫Á±ªÂûã
    remove(id) {
        if (this.enemies.has(id)) {
            this.enemies.delete(id);
            this.saveToStorage(); // Âà†Èô§Âêé‰øùÂ≠ò
            return true;
        }
        return false;
    }

    // Ê£ÄÊü•Êïå‰∫∫ÊòØÂê¶ÈÖçÁΩÆÂÆåÊï¥ÔºàÁî®‰∫éÁÉòÁÑôÊó∂È™åËØÅÔºâ
    validate(id) {
        const enemy = this.get(id);
        const warnings = [];
        
        if (!enemy.scenePath) {
            warnings.push(`Êïå‰∫∫ "${enemy.name}" (${id}) Áº∫Â∞ëÂú∫ÊôØË∑ØÂæÑ (scenePath)`);
        }
        if (!enemy.uid) {
            warnings.push(`Êïå‰∫∫ "${enemy.name}" (${id}) Áº∫Â∞ëËµÑÊ∫êUID (uid)`);
        }
        
        return {
            valid: warnings.length === 0,
            warnings
        };
    }

    // È™åËØÅÊâÄÊúâÊïå‰∫∫ÈÖçÁΩÆ
    validateAll() {
        const allWarnings = [];
        this.enemies.forEach((enemy, id) => {
            const result = this.validate(id);
            if (!result.valid) {
                allWarnings.push(...result.warnings);
            }
        });
        return {
            valid: allWarnings.length === 0,
            warnings: allWarnings
        };
    }
}

// ÂÖ®Â±ÄÊïå‰∫∫Á±ªÂûãÊ≥®ÂÜåË°®ÂÆû‰æã
const enemyTypeRegistry = new EnemyTypeRegistry();

// ‰∫ã‰ª∂Á±ªÂûãÊ≥®ÂÜåË°®
class EventTypeRegistry {
    constructor() {
        this.types = new Map();
        this.registerDefaultTypes();
    }

    // Ê≥®ÂÜåÈªòËÆ§‰∫ã‰ª∂Á±ªÂûã
    registerDefaultTypes() {
        this.register('spawn_enemy', {
            name: 'ÁîüÊàêÊïå‰∫∫',
            color: '#e74c3c',
            icon: 'üëæ',
            fields: {
                enemyType: 'basic_enemy',  // Êïå‰∫∫ID
                count: 1,                   // ÁîüÊàêÊï∞Èáè
                spawnPosition: 'random',    // ÁîüÊàê‰ΩçÁΩÆ: random, left, right, top, bottom, center
                formationType: 'single',    // ÁºñÈòü: single, line, circle, grid
            }
        });

        this.register('marker', {
            name: 'Ê†áËÆ∞ÁÇπ',
            color: '#95a5a6',
            icon: 'üö©',
            fields: {
                label: '',
                note: '',
            }
        });
    }

    // Ê≥®ÂÜåÊñ∞ÁöÑ‰∫ã‰ª∂Á±ªÂûã
    register(id, config) {
        this.types.set(id, config);
    }

    // Ëé∑Âèñ‰∫ã‰ª∂Á±ªÂûã
    get(id) {
        return this.types.get(id) || this.types.get('default');
    }

    // Ëé∑ÂèñÊâÄÊúâ‰∫ã‰ª∂Á±ªÂûã
    getAll() {
        return Array.from(this.types.entries()).map(([id, config]) => ({
            id,
            ...config
        }));
    }
}

// ÂÖ®Â±Ä‰∫ã‰ª∂Á±ªÂûãÊ≥®ÂÜåË°®ÂÆû‰æã
const eventTypeRegistry = new EventTypeRegistry();

// ‰∫ã‰ª∂Âü∫Á±ª
class TimelineEvent {
    constructor(time, type = 'default', customData = {}) {
        this.id = this.generateId();
        this.time = time; // Ëß¶ÂèëÊó∂Èó¥ÁÇπÔºàÁßíÔºâ
        this.type = type; // ‰∫ã‰ª∂Á±ªÂûã
        this.customData = customData; // Ëá™ÂÆö‰πâÊï∞ÊçÆ
        this.createdAt = new Date();
        this.updatedAt = new Date();
    }

    generateId() {
        return 'event_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
    }

    // Êõ¥Êñ∞‰∫ã‰ª∂
    update(data) {
        Object.assign(this, data);
        this.updatedAt = new Date();
    }

    // Ëé∑Âèñ‰∫ã‰ª∂Á±ªÂûãÈÖçÁΩÆ
    getTypeConfig() {
        return eventTypeRegistry.get(this.type);
    }

    // Â∫èÂàóÂåñ
    toJSON() {
        return {
            id: this.id,
            time: this.time,
            type: this.type,
            customData: this.customData,
            createdAt: this.createdAt,
            updatedAt: this.updatedAt,
        };
    }

    // ‰ªéJSONÊÅ¢Â§ç
    static fromJSON(json) {
        const event = new TimelineEvent(json.time, json.type, json.customData);
        event.id = json.id;
        event.createdAt = new Date(json.createdAt);
        event.updatedAt = new Date(json.updatedAt);
        return event;
    }
}

// ËΩ®ÈÅìÁ±ª
class Track {
    constructor(name = 'Êñ∞ËΩ®ÈÅì') {
        this.id = this.generateId();
        this.name = name;
        this.events = []; // ‰∫ã‰ª∂Êï∞ÁªÑ
        this.color = this.randomColor();
        this.visible = true;
        this.locked = false;
    }

    generateId() {
        return 'track_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
    }

    randomColor() {
        const colors = ['#007acc', '#e74c3c', '#2ecc71', '#f39c12', '#9b59b6', '#1abc9c'];
        return colors[Math.floor(Math.random() * colors.length)];
    }

    // Ê∑ªÂä†‰∫ã‰ª∂
    addEvent(event) {
        this.events.push(event);
        this.sortEvents();
        return event;
    }

    // Âà†Èô§‰∫ã‰ª∂
    removeEvent(eventId) {
        const index = this.events.findIndex(e => e.id === eventId);
        if (index > -1) {
            this.events.splice(index, 1);
            return true;
        }
        return false;
    }

    // Ëé∑Âèñ‰∫ã‰ª∂
    getEvent(eventId) {
        return this.events.find(e => e.id === eventId);
    }

    // ÊåâÊó∂Èó¥ÊéíÂ∫è‰∫ã‰ª∂
    sortEvents() {
        this.events.sort((a, b) => a.time - b.time);
    }

    // Ëé∑ÂèñÊåáÂÆöÊó∂Èó¥ËåÉÂõ¥ÂÜÖÁöÑ‰∫ã‰ª∂
    getEventsInRange(startTime, endTime) {
        return this.events.filter(e => e.time >= startTime && e.time <= endTime);
    }

    // Â∫èÂàóÂåñ
    toJSON() {
        return {
            id: this.id,
            name: this.name,
            events: this.events.map(e => e.toJSON()),
            color: this.color,
            visible: this.visible,
            locked: this.locked,
        };
    }

    // ‰ªéJSONÊÅ¢Â§ç
    static fromJSON(json) {
        const track = new Track(json.name);
        track.id = json.id;
        track.color = json.color;
        track.visible = json.visible;
        track.locked = json.locked;
        track.events = json.events.map(e => TimelineEvent.fromJSON(e));
        return track;
    }
}

// Êó∂Èó¥ËΩ¥Á±ª
class Timeline {
    constructor(duration = 60) {
        this.id = this.generateId();
        this.duration = duration; // ÊÄªÊó∂ÈïøÔºàÁßíÔºâ
        this.tracks = [];
        this.currentTime = 0; // ÂΩìÂâçÊí≠ÊîæÊó∂Èó¥
        this.zoom = 10; // Áº©ÊîæÁ∫ßÂà´ÔºàÂÉèÁ¥†/ÁßíÔºâ
        this.name = 'Êú™ÂëΩÂêçÊó∂Èó¥ËΩ¥';
        this.createdAt = new Date();
    }

    generateId() {
        return 'timeline_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
    }

    // Ê∑ªÂä†ËΩ®ÈÅì
    addTrack(track) {
        this.tracks.push(track);
        return track;
    }

    // Âà†Èô§ËΩ®ÈÅì
    removeTrack(trackId) {
        const index = this.tracks.findIndex(t => t.id === trackId);
        if (index > -1) {
            this.tracks.splice(index, 1);
            return true;
        }
        return false;
    }

    // Ëé∑ÂèñËΩ®ÈÅì
    getTrack(trackId) {
        return this.tracks.find(t => t.id === trackId);
    }

    // ËÆæÁΩÆÊó∂Èïø
    setDuration(duration) {
        this.duration = Math.max(10, duration);
    }

    // Ëé∑ÂèñÊâÄÊúâ‰∫ã‰ª∂
    getAllEvents() {
        return this.tracks.flatMap(track => 
            track.events.map(event => ({
                track,
                event
            }))
        );
    }

    // Ëé∑ÂèñÊåáÂÆöÊó∂Èó¥ÁÇπÁöÑÊâÄÊúâ‰∫ã‰ª∂
    getEventsAtTime(time, tolerance = 0.1) {
        return this.getAllEvents().filter(({ event }) => 
            Math.abs(event.time - time) <= tolerance
        );
    }

    // Â∫èÂàóÂåñ
    toJSON() {
        return {
            id: this.id,
            name: this.name,
            duration: this.duration,
            tracks: this.tracks.map(t => t.toJSON()),
            currentTime: this.currentTime,
            zoom: this.zoom,
            createdAt: this.createdAt,
        };
    }

    // ‰ªéJSONÊÅ¢Â§ç
    static fromJSON(json) {
        const timeline = new Timeline(json.duration);
        timeline.id = json.id;
        timeline.name = json.name;
        timeline.currentTime = json.currentTime;
        timeline.zoom = json.zoom;
        timeline.createdAt = new Date(json.createdAt);
        timeline.tracks = json.tracks.map(t => Track.fromJSON(t));
        return timeline;
    }

    // ÂØºÂá∫‰∏∫JSONÂ≠óÁ¨¶‰∏≤
    export() {
        return JSON.stringify(this.toJSON(), null, 2);
    }

    // ‰ªéJSONÂ≠óÁ¨¶‰∏≤ÂØºÂÖ•
    static import(jsonString) {
        try {
            const json = JSON.parse(jsonString);
            return Timeline.fromJSON(json);
        } catch (error) {
            console.error('ÂØºÂÖ•Â§±Ë¥•:', error);
            return null;
        }
    }
}
